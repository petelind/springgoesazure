This is content I intend to cover during 2 weeks Sep 11 - Sep 22.

Spring Boot:
  Core concepts:      
    ✔ extension to the Spring Framework Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run" @done(23-09-11 10:47)
    ✔ Runs its own container as opposed to WAR files @done(23-09-11 10:47)
    ✔ Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run" @done(23-09-12 06:11)
    ✔ pom.xml: spring-boot-starter @done(23-09-12 06:11)
    @Component - generic stereotype for any Spring-managed component: 
      ✔ Aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. @done(23-09-11 10:47)
      ✔ @Repository - stereotype for persistence layer @done(23-09-11 10:47)
      ✔ @Service - stereotype for service layer @done(23-09-11 10:47)
      ✔ @Controller - stereotype for presentation layer (spring-mvc) @done(23-09-11 10:48)
      ✔ @RestController - stereotype for presentation layer (spring-mvc) - returns JSON @done(23-09-11 10:48)
      ✔ @Configuration - indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime @done(23-09-11 10:48)
      ✔ @EnableAutoConfiguration - enable Spring Boot’s auto-configuration mechanism @done(23-09-11 10:48)
      ✔ @Autowired - I want an instance injected here @done(23-09-11 10:48)
    ✔  mvnm spring-boot:run @done(23-09-13 09:00)
    ☐ @SpringBootApplication annotation: @Configuration, @EnableAutoConfiguration, @ComponentScan
      ✔ some properties still need to be provided like server names etc. @done(23-09-11 10:48)
      ✔ use can use @override to override the default values @done(23-09-11 10:48)
      ✔ java -jar target/myproject-0.0.1-SNAPSHOT.jar --debug to see what is being autoconfigured @done(23-09-11 10:48)
  Lets build app bottom up all the way to controller:
    ✔ Add @repository to the repository class (no persistence layer yet) @done(23-09-11 14:12)
    Annotate to turn into rest controller:
      ✔ @RestController @done(23-09-11 14:12)
      ✔ @RequestMapping("/questions") so you can omit path later on @done(23-09-11 14:12)
      ✔ @GetMapping("/questions") vs getQ@RequestMapping(method=RequestMethod.GET) {...} @done(23-09-11 14:12)
      ✔ @GetMapping(path="/questions/{id}") getQ(@PathVariable("id")) int id) {..} @done(23-09-11 14:12)
      ✔ @GetMapping(path="/questions") getQ(@RequestParam("id")) int id) {..} @done(23-09-11 14:12)
      ✔ General consideration - adopt a convention (uniform mapping or entity access) @done(23-09-11 14:12)
      ✔ @PostMapping Question createQuestion(@RequestBody Question question) {..} @done(23-09-11 14:12)
      ✔ Getting data in @RequestBody - JSON @done(23-09-11 14:12)
      ✔ Exercise: add POST and PUT to the controller @done(23-09-11 14:12)
    Handling exceptions:
      ✔ methodName throws KindOfException {..} @done(23-09-11 14:12)
      ✔ 500 - Internal Server Error not a proper way @done(23-09-11 14:12)
      ☐ return mathQuestionsRepo.findById(id).orElseThrow(() -> new NoSuchElementException(id));
      ✔ @ExceptionHandler(KindOfException.class) public ErrorResponse handleException(NoSuchElementException ex) {..} @done(23-09-11 14:12)
        ✔ return ErrorResponse.create(ex, HttpStatus.NOT_FOUND, ex.getMessage()); @done(23-09-11 14:12)
      Validation: 
        ✔ spring-boot-validation dependency @done(23-09-11 14:12)
        ✔ @Valid @RequestBody Question question @done(23-09-11 14:12)
        Domain annotations:
        ✔ @NotNull(message = "Question is mandatory") @done(23-09-11 14:12)
        ✔ @Size(min = 2, message = "Question should have at least 2 characters") @done(23-09-11 14:12)
        ✔ @Size(max = 100, message = "Question should have at most 100 characters") @done(23-09-11 14:12)
        ✔ @Pattern(regexp = "[A-Za-z0-9 ]*", message = "Question has invalid characters") @done(23-09-11 14:12)
        ✔ @NotBlank(message = "Question cannot be blank") @done(23-09-11 14:12)
        ✔ Then you can throw ConstraintViolationException and handle it in the controller with the error response of type ErrorResponse HttpStatus.BAD_REQUEST @done(23-09-11 14:12)
        
    Persistence:
        ✔ core vs community Spring Data libs @done(23-09-12 20:09)
        ✔ CrudRepository @done(23-09-12 20:09)
        ✔ public interface MathQuestionsRepo extends JpaRepository<Question, Integer> {..} @done(23-09-12 20:09)
        ✔ [or DBSpecificTypeRepository] @done(23-09-12 20:09)
        ✔ @Entity vs @Document @done(23-09-12 20:09)
          ✔ @Id in @Document are strings! @done(23-09-12 20:09)
          ✔ UUID is the most common type for @Id @done(23-09-12 20:09)
          ✔ @Entity - GeneratedValue(strategy = GenerationType.IDENTITY) for autoincrement for id @done(23-09-12 20:10)
        ✔ Declare your repo as above and Spring will autoconfigure it for you @done(23-09-12 20:10)
        ✔ findById, findAll, save, delete, deleteAll etc. will be autoconfigured if you follow convention @done(23-09-12 20:10)
        ✔ @Override if you want your own implementation @done(23-09-12 20:10)
        ✔ Exercise: add NoSQL persistence just for fun (we will not use it) @done(23-09-12 20:10)
        ✔ Sidenotes: @done(23-09-12 20:10)
            ✔ not much fun with RDMBS - initializing schema and data with profiles @done(23-09-12 20:10)
            ✔ Managing migrations with flyway @done(23-09-12 20:10)
    Configuring the app with externalized configuration:
        ☐ application.properties in src/main/resources/application.yml
        ✔ mvn sprint-boot:run -Dspring-boot.run.profiles=localenv @done(23-09-12 20:10)
    Reactive programming:
      ✔ Batch processing vs producer/consumer processing @done(23-09-12 20:10)
      ✔ The concept of CompletableFuture (a promise of a value) @done(23-09-12 20:10)
      ✔ The concept of Mono and Flux @done(23-09-12 20:10)
      ✔ Blocking @done(23-09-12 20:10)


  Docker:
    Basic commands: 
      ✔ docker run -it ubuntu bash @done(23-09-12 20:10)
      ✔ docker run mongo -d @done(23-09-12 20:10)
      ✔ docker stop <container id> @done(23-09-12 20:10)
      ✔ docker run -p 27017:27017 mongo @done(23-09-12 20:10)
      ✔ docker ps @done(23-09-12 20:10)
      ✔ docker ps -a @done(23-09-12 20:10)
      ✔ docker images @done(23-09-12 20:10)
      ✔ docker rm <container id> @done(23-09-12 20:10)
      ✔ docker rmi <image id> @done(23-09-12 20:10)
      ✔ docker run -d -p 8080:8080 --name myapp myapp @done(23-09-12 20:10)
      ✔ docker exec -it <container id> bash @done(23-09-12 20:10)
      ✔ docker stop <container id> @done(23-09-12 20:10)
      ✔ docker start <container id>- @done(23-09-12 20:10)
      ✔ docker logs <container id> @done(23-09-12 20:10)
    Building:
      ✔ Create a Dockerfile @done(23-09-13 20:05)
      ✔ FROM openjdk:17-jdk-alpine @done(23-09-13 20:05)
      ✔ talk through the structure @done(23-09-13 20:05)
      ✔ Docker build . @done(23-09-13 20:05)
      ✔ Docker build -t <name> . @done(23-09-13 20:05)
      ✔ Docker build -t <name>:<tag> . @done(23-09-13 20:05)
      ✔ Docker build @done(23-09-13 20:05)
      ✔ -t <name>:<tag> -f <dockerfile name> . @done(23-09-13 20:05)
      ✔ Docker build -t <name>:<tag> -f <dockerfile name> --build-arg <arg name>=<arg value> . @done(23-09-13 20:05)
      ✔ Docker build -t <name>:<tag> -f <dockerfile name> --build-arg <arg name>=<arg value> --build-arg <arg name>=<arg value> . @done(23-09-13 20:05)
      ✔ Layers @done(23-09-13 20:05)
      ✔ mvn spring-boot:build-image @done(23-09-13 20:05)
      ✔ tagging: @done(23-09-13 20:05)
          docker tag <image id> <acr url/<repo name>:<tag>
          docker tag <image id> <dockerhub username>/<repo name>:latest
          docker tag <image id> <dockerhub username>/<repo name>:$(git rev-parse --short HEAD)
          docker push --all-tags <acr url/<repo name>
      ✔ Exercise: create script which builds, tags, and pushes to the registry @done(23-09-13 20:05)
      ✔ Exercise: using "acr build" command @done(23-09-13 20:05)

  Kubernetes:
    Core concepts:
        ✔ Core services: API Server, Scheduler, Controller Manager, etcd @done(23-09-15 08:17)
        ✔ Cluster and its edge @done(23-09-15 08:17)
        ✔ Nodes @done(23-09-15 08:17)
        ✔ Pods @done(23-09-15 08:17)
        ✔ ReplicaSets @done(23-09-15 08:17)
        ✔ Deployments @done(23-09-15 08:17)
        ✔ Services @done(23-09-15 08:17)
            ✔ Labels and selectors @done(23-09-15 08:17)
        ✔ Ingress @done(23-09-15 08:17)
        ✔ ConfigMaps @done(23-09-15 08:17)
        ✔ Secrets @done(23-09-15 08:17)
        ✔ Namespaces @done(23-09-15 08:17)
        ✔ /api/ and talking to it @done(23-09-15 08:17)
        ✔ Exercise: deploy our app @done(23-09-15 08:17)
    Running local:
      Deploying imperative way:
        kubectl get pods --namespace kube-system
        kubectl create namespace dumbapp
        kubectl config set-context --current --namespace=dumbapp
        sudo lsof -i :80
        kubectl create deployment dumbapp-deployment --image=manojnair/myapp:v1 --port=80
        kubectl get deployments
        kubectl describe deployment <name>
        kubectl expose deployment dumbapp-deployment --name dumbapp-service --type=ClusterIP --port=80 --target-port=80
        kubectl expose service dumbapp-deployment --name dumbapp-endpoint --type=LoadBalancer --port=80 --target-port=80
        kubectl get svc --watch
        sudo kubectl port-forward service/<name> 80:80 *) How to make it work :)
        kubectl create configmap <name> --from-literal=<key>=<value>
        kubectl create configmap <name> --from-file=<path>
        kubectl get pods
        kubectl get pods -o wide
        kubectl logs <name>
        kubectl scale deployment <name> --replicas=10
        kubectl edit deployment <name> --record=true
        kubectl rollout history deployment/<name>
        kubectl rollout undo deployment/<name>
        kubectl rollout undo deployment/<name> --to-revision=X
        Exercise: kill a pod, see what happens: kubectl delete pod <pod name>

    Declarative VS imperative:
      ☐ Deploying declarative (not really) way with YAML
      Exercise: deploy with YAML
        kubectl create deployment <name> --image=<image> --dry-run=client -o yaml > deployment.yaml
        kubectl edit deployment <name>
        Attention: pull policy = Never
        ☐ Exercise: add a config map
        ☐ Exercise: add a deployment for each service
        ☐ Exercise: add a service for each deployment
        ☐ Exercise: expose the service / deployment
        OR
        ☐ Exercise: or find an error
        kubectl run -it --rm --image=curlimages/curl curly -- sh
        ☐ Exercise: enable health checks
        ☐ Exercise: Implement a custom health check
        ☐ WARNING: pitfalls of health checks
    
    Azure:
      Design considerations:
        ☐ Complexity of your solution: exponential vs logarithmic
        ☐ SPSTC(p)W: Simplest possible solution that could (possibly) work
        ☐ Locality
        ☐ Availability
        ☐ Security and the attack surface
        ☐ Maintainability: do we need a Caterpillar truck?
      Core styles and entities:
        ☐ IaaS VS PaaS vs SaaS
        ☐ CaaS: retain some independence

    Running in AKS:
      ☐ Go through playbook
      ☐ Moving role definitions into separate deployment.yaml
      ☐ Attention: pull policy = Always!
      

    Scaling:
      ☐ Manual and Auto
      ☐ Exercise: bring up more replicas
        kubectl scale <deployment name> --replicas=X
        kubectl scale --name <cluster> --node-count=X
      ☐ Exercise: set up autoscaling
    Self-healing:
      ☐ Actuator
      ☐ Liveness and readiness probes

    Release strategy:
    ☐ Using kubectl edit <resource> --record=true
      ☐ kubectl rollout history <resourcetype>/name
      ☐ Roll back - kubectl rollout undo <resource>
      ☐ Roll back - kubectl rollout undo <resource> --to-revision=X
    ☐ Using selectors & labels
    ☐ Using clusters (repaving)
    ☐ Using namespaces
    Publishing:
      ☐ DNS - A-names for blue and green, CNAME for the app
      ☐ Traffic Manager
      ☐ Front Door
  

  CosmosDB:
    Relational vs NoSQL vs Graph
    Gremlin interface
    Geo-replication
    Consistency levels
    Partitioning: how to choose the key
    Indexing:
    Scaling: provisioned VS serverless
    Accessing: public endpoint vs private endpoint
    Exercise: create a CosmosDB account & use Data Explorer
        CRUD Questions
        Search Questions
    Getting data into Gremlin: no out-of-the-box solution;
        write your own with BulkExecutor
        or dump into JSON then use Data Import tool with JSON
        https://learn.microsoft.com/en-us/azure/cosmos-db/migration-choices




