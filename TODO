This is content I intend to cover during 2 weeks Sep 11 - Sep 22.

Spring Boot:
  Core concepts:      
    ✔ extension to the Spring Framework Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run" @done(23-09-11 10:47)
    ✔ Runs its own container as opposed to WAR files @done(23-09-11 10:47)
    ✔ Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run" @done(23-09-12 06:11)
    ✔ pom.xml: spring-boot-starter @done(23-09-12 06:11)
    @Component - generic stereotype for any Spring-managed component: 
      ✔ Aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. @done(23-09-11 10:47)
      ✔ @Repository - stereotype for persistence layer @done(23-09-11 10:47)
      ✔ @Service - stereotype for service layer @done(23-09-11 10:47)
      ✔ @Controller - stereotype for presentation layer (spring-mvc) @done(23-09-11 10:48)
      ✔ @RestController - stereotype for presentation layer (spring-mvc) - returns JSON @done(23-09-11 10:48)
      ✔ @Configuration - indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime @done(23-09-11 10:48)
      ✔ @EnableAutoConfiguration - enable Spring Boot’s auto-configuration mechanism @done(23-09-11 10:48)
      ✔ @Autowired - I want an instance injected here @done(23-09-11 10:48)
    ✔  mvnm spring-boot:run @done(23-09-13 09:00)
    ✔ @SpringBootApplication annotation: @Configuration, @EnableAutoConfiguration, @ComponentScan @done(23-09-18 08:32)
      ✔ some properties still need to be provided like server names etc. @done(23-09-11 10:48)
      ✔ use can use @override to override the default values @done(23-09-11 10:48)
      ✔ java -jar target/myproject-0.0.1-SNAPSHOT.jar --debug to see what is being autoconfigured @done(23-09-11 10:48)
  Lets build app bottom up all the way to controller:
    ✔ Add @repository to the repository class (no persistence layer yet) @done(23-09-11 14:12)
    Annotate to turn into rest controller:
      ✔ @RestController @done(23-09-11 14:12)
      ✔ @RequestMapping("/questions") so you can omit path later on @done(23-09-11 14:12)
      ✔ @GetMapping("/questions") vs getQ@RequestMapping(method=RequestMethod.GET) {...} @done(23-09-11 14:12)
      ✔ @GetMapping(path="/questions/{id}") getQ(@PathVariable("id")) int id) {..} @done(23-09-11 14:12)
      ✔ @GetMapping(path="/questions") getQ(@RequestParam("id")) int id) {..} @done(23-09-11 14:12)
      ✔ General consideration - adopt a convention (uniform mapping or entity access) @done(23-09-11 14:12)
      ✔ @PostMapping Question createQuestion(@RequestBody Question question) {..} @done(23-09-11 14:12)
      ✔ Getting data in @RequestBody - JSON @done(23-09-11 14:12)
      ✔ Exercise: add POST and PUT to the controller @done(23-09-11 14:12)
    Handling exceptions:
      ✔ methodName throws KindOfException {..} @done(23-09-11 14:12)
      ✔ 500 - Internal Server Error not a proper way @done(23-09-11 14:12)
      ✔ return mathQuestionsRepo.findById(id).orElseThrow(() -> new NoSuchElementException(id)); @done(23-09-18 08:32)
      ✔ @ExceptionHandler(KindOfException.class) public ErrorResponse handleException(NoSuchElementException ex) {..} @done(23-09-11 14:12)
        ✔ return ErrorResponse.create(ex, HttpStatus.NOT_FOUND, ex.getMessage()); @done(23-09-11 14:12)
      Validation: 
        ✔ spring-boot-validation dependency @done(23-09-11 14:12)
        ✔ @Valid @RequestBody Question question @done(23-09-11 14:12)
        Domain annotations:
        ✔ @NotNull(message = "Question is mandatory") @done(23-09-11 14:12)
        ✔ @Size(min = 2, message = "Question should have at least 2 characters") @done(23-09-11 14:12)
        ✔ @Size(max = 100, message = "Question should have at most 100 characters") @done(23-09-11 14:12)
        ✔ @Pattern(regexp = "[A-Za-z0-9 ]*", message = "Question has invalid characters") @done(23-09-11 14:12)
        ✔ @NotBlank(message = "Question cannot be blank") @done(23-09-11 14:12)
        ✔ Then you can throw ConstraintViolationException and handle it in the controller with the error response of type ErrorResponse HttpStatus.BAD_REQUEST @done(23-09-11 14:12)
        
    Persistence:
        ✔ core vs community Spring Data libs @done(23-09-12 20:09)
        ✔ CrudRepository @done(23-09-12 20:09)
        ✔ public interface MathQuestionsRepo extends JpaRepository<Question, Integer> {..} @done(23-09-12 20:09)
        ✔ [or DBSpecificTypeRepository] @done(23-09-12 20:09)
        ✔ @Entity vs @Document @done(23-09-12 20:09)
          ✔ @Id in @Document are strings! @done(23-09-12 20:09)
          ✔ UUID is the most common type for @Id @done(23-09-12 20:09)
          ✔ @Entity - GeneratedValue(strategy = GenerationType.IDENTITY) for autoincrement for id @done(23-09-12 20:10)
        ✔ Declare your repo as above and Spring will autoconfigure it for you @done(23-09-12 20:10)
        ✔ findById, findAll, save, delete, deleteAll etc. will be autoconfigured if you follow convention @done(23-09-12 20:10)
        ✔ @Override if you want your own implementation @done(23-09-12 20:10)
        ✔ Exercise: add NoSQL persistence just for fun (we will not use it) @done(23-09-12 20:10)
        ✔ Sidenotes: @done(23-09-12 20:10)
            ✔ not much fun with RDMBS - initializing schema and data with profiles @done(23-09-12 20:10)
            ✔ Managing migrations with flyway @done(23-09-12 20:10)
    Configuring the app with externalized configuration:
        ✔ application.properties in src/main/resources/application.yml @done(23-09-18 08:32)
        ✔ mvn sprint-boot:run -Dspring-boot.run.profiles=localenv @done(23-09-12 20:10)
    Reactive programming:
      ✔ Batch processing vs producer/consumer processing @done(23-09-12 20:10)
      ✔ The concept of CompletableFuture (a promise of a value) @done(23-09-12 20:10)
      ✔ The concept of Mono and Flux @done(23-09-12 20:10)
      ✔ Blocking @done(23-09-12 20:10)


  Docker:
    Basic commands: 
      ✔ docker run -it ubuntu bash @done(23-09-12 20:10)
      ✔ docker run mongo -d @done(23-09-12 20:10)
      ✔ docker stop <container id> @done(23-09-12 20:10)
      ✔ docker run -p 27017:27017 mongo @done(23-09-12 20:10)
      ✔ docker ps @done(23-09-12 20:10)
      ✔ docker ps -a @done(23-09-12 20:10)
      ✔ docker images @done(23-09-12 20:10)
      ✔ docker rm <container id> @done(23-09-12 20:10)
      ✔ docker rmi <image id> @done(23-09-12 20:10)
      ✔ docker run -d -p 8080:8080 --name myapp myapp @done(23-09-12 20:10)
      ✔ docker exec -it <container id> bash @done(23-09-12 20:10)
      ✔ docker stop <container id> @done(23-09-12 20:10)
      ✔ docker start <container id>- @done(23-09-12 20:10)
      ✔ docker logs <container id> @done(23-09-12 20:10)
    Building:
      ✔ Create a Dockerfile @done(23-09-13 20:05)
      ✔ FROM openjdk:17-jdk-alpine @done(23-09-13 20:05)
      ✔ talk through the structure @done(23-09-13 20:05)
      ✔ Docker build . @done(23-09-13 20:05)
      ✔ Docker build -t <name> . @done(23-09-13 20:05)
      ✔ Docker build -t <name>:<tag> . @done(23-09-13 20:05)
      ✔ Docker build @done(23-09-13 20:05)
      ✔ -t <name>:<tag> -f <dockerfile name> . @done(23-09-13 20:05)
      ✔ Docker build -t <name>:<tag> -f <dockerfile name> --build-arg <arg name>=<arg value> . @done(23-09-13 20:05)
      ✔ Docker build -t <name>:<tag> -f <dockerfile name> --build-arg <arg name>=<arg value> --build-arg <arg name>=<arg value> . @done(23-09-13 20:05)
      ✔ Layers @done(23-09-13 20:05)
      ✔ mvn spring-boot:build-image @done(23-09-13 20:05)
      ✔ tagging: @done(23-09-13 20:05)
          ✔ docker tag <image id> <acr url/<repo name>:<tag> @done(23-09-18 08:32)
          ✔ docker tag <image id> <dockerhub username>/<repo name>:latest @done(23-09-18 08:32)
          ✔ docker tag <image id> <dockerhub username>/<repo name>:$(git rev-parse --short HEAD) @done(23-09-18 08:32)
          ✔ docker push --all-tags <acr url/<repo name> @done(23-09-18 08:32)
      ✔ Exercise: create script which builds, tags, and pushes to the registry @done(23-09-13 20:05)
      ✔ Exercise: using "acr build" command @done(23-09-13 20:05)

  Kubernetes:
    Core concepts:
        ✔ Core services: API Server, Scheduler, Controller Manager, etcd @done(23-09-15 08:17)
        ✔ Cluster and its edge @done(23-09-15 08:17)
        ✔ Nodes @done(23-09-15 08:17)
        ✔ Pods @done(23-09-15 08:17)
        ✔ ReplicaSets @done(23-09-15 08:17)
        ✔ Deployments @done(23-09-15 08:17)
        ✔ Services @done(23-09-15 08:17)
            ✔ Labels and selectors @done(23-09-15 08:17)
        ✔ Ingress @done(23-09-15 08:17)
        ✔ ConfigMaps @done(23-09-15 08:17)
        ✔ Secrets @done(23-09-15 08:17)
        ✔ Namespaces @done(23-09-15 08:17)
        ✔ /api/ and talking to it @done(23-09-15 08:17)
        ✔ Exercise: deploy our app @done(23-09-15 08:17)
    Running local:
      ✔ Deploying imperative way: @done(23-09-18 08:31)
        ✔ kubectl get pods --namespace kube-system @done(23-09-18 08:32)
        ✔ kubectl create namespace dumbapp @done(23-09-18 08:32)
        ✔ kubectl config set-context --current --namespace=dumbapp @done(23-09-18 08:32)
        ✔ kubectl config view --minify | grep namespace: @done(23-09-18 08:32)
        ✔ sudo lsof -i :80 @done(23-09-18 08:32)
        ✔ kubectl create deployment dumbapp-deployment --image=manojnair/myapp:v1 --port=80 @done(23-09-18 08:32)
        ✔ kubectl get deployments @done(23-09-18 08:32)
        ✔ kubectl describe deployment <name> @done(23-09-18 08:32)
        ✔ kubectl expose deployment dumbapp-deployment --name dumbapp-service --type=ClusterIP --port=80 --target-port=80 @done(23-09-18 08:32)
        ✔ kubectl expose service dumbapp-service --name dumbapp-endpoint --type=LoadBalancer --port=80 --target-port=80 @done(23-09-18 08:32)
        ✔ kubectl get svc --watch @done(23-09-18 08:32)
        ✔ sudo kubectl port-forward service/<name> 80:80 *) How to make it work :) @done(23-09-18 08:32)
        ✔ kubectl create configmap <name> --from-literal=<key>=<value> @done(23-09-18 08:32)
        ✔ kubectl create configmap <name> --from-file=<path> @done(23-09-18 08:32)
        ✔ kubectl get pods @done(23-09-18 08:32)
        ✔ kubectl get pods -o wide @done(23-09-18 08:32)
        ✔ kubectl logs <name> @done(23-09-18 08:32)
        ✔ kubectl scale deployment <name> --replicas=10 @done(23-09-18 08:32)
        ✔ kubectl scale deployment <name> --node-count=3 @done(23-09-18 08:32)
        ✔ kubectl edit deployment <name> --record=true @done(23-09-18 08:32)
        ✔ kubectl rollout history deployment/<name> @done(23-09-18 08:32)
        ✔ kubectl rollout undo deployment/<name>sudo @done(23-09-18 08:32)
        ✔ kubectl rollout undo deployment/<name> --to-revision=X @done(23-09-18 08:32)
        ✔ Exercise: kill a pod, see what happens: kubectl delete pod <pod name>kubect @done(23-09-18 08:32)

    ✔ Declarative VS imperative: @done(23-09-18 08:31)
      ✔ Deploying declarative (not really) way with YAML @done(23-09-18 08:31)
      ✔ Exercise: deploy with YAML @done(23-09-18 08:31)
        ✔ kubectl create deployment <name> --image=<image> --dry-run=client -o yaml > deployment.yaml @done(23-09-18 08:32)
        ✔ kubectl edit deployment <name> @done(23-09-18 08:32)
        ✔ Attention: pull policy = Never @done(23-09-18 08:32)
        ✘ Exercise: add a config map @cancelled(23-09-18 08:32)
        ✘ Exercise: add a deployment for each service @cancelled(23-09-18 08:32)
        ✘ Exercise: add a service for each deployment @cancelled(23-09-18 08:32)
        ✘ Exercise: expose the service / deployment @cancelled(23-09-18 08:32)
        OR
        ✔ Exercise: or find an error @done(23-09-18 08:31)
        ✔ kubectl run -it --rm --image=curlimages/curl curly -- sh @done(23-09-18 08:31)
        ✔ Exercise: enable health checks @done(23-09-18 08:31)
        ✔ Exercise: Implement a custom health check @done(23-09-18 08:31)
        ✔ WARNING: pitfalls of health checks @done(23-09-18 08:31)
    
    Azure:
      Design considerations:
        ✔ Complexity of your solution: exponential vs logarithmic @done(23-09-18 08:56)
        ☐ SPSTC(p)W: Simplest possible solution that could (possibly) work
        ☐ Locality
        ☐ Availability
        ☐ Security and the attack surface
          ☐ Public vs private endpoints
          ☐ VNets
          ☐ Application gateways 
        ☐ Maintainability: do we need a Caterpillar truck?
      Core styles and entities:
        ✔ IaaS VS PaaS vs SaaS @done(23-09-18 08:29)
        ✔ CaaS: retain some independence @done(23-09-18 08:29)

    Running in AKS:
      ☐ Go through playbook
      ☐ Go through deployment.yaml - enabling access
      ☐ Moving role definitions into separate deployment.yaml

    Scaling:
      ☐ Manual and Auto
      Self-healing:
        ☐ Actuator
        ☐ Liveness and readiness probes
      ☐ Exercise: bring up more replicas
        kubectl scale <deployment name> --replicas=X
        kubectl scale --name <cluster> --node-count=X
        az aks scale --resource-group <resource-group-name> --name <aks-cluster-name> --node-count X
      ☐ Exercise: set up autoscaling with new application.yaml
    
    Release strategy:
    ✔ Using kubectl edit <resource> --record=true @done(23-09-18 08:55)
      ✔ kubectl rollout history <resourcetype>/name @done(23-09-18 08:55)
      ✔ Roll back - kubectl rollout undo <resource> @done(23-09-18 08:56)
      ✔ Roll back - kubectl rollout undo <resource> --to-revision=X @done(23-09-18 08:56)
    ☐ Using selectors & labels
    ☐ Using clusters (repaving)
    ☐ Using namespaces
    Publishing:
      ☐ DNS - A-names for blue and green, CNAME for the app
      ☐ Traffic Manager
      ☐ Front Door
  

  CosmosDB:
    Relational vs NoSQL vs Graph
    Gremlin interface
    Geo-replication
    Consistency levels
    Partitioning: how to choose the key
    Indexing:
    Scaling: provisioned VS serverless
    Accessing: public endpoint vs private endpoint
    Exercise: create a CosmosDB account & use Data Explorer
        CRUD Questions
        Search Questions
    Getting data into Gremlin: no out-of-the-box solution;
        write your own with BulkExecutor
        or dump into JSON then use Data Import tool with JSON
        https://learn.microsoft.com/en-us/azure/cosmos-db/migration-choices




